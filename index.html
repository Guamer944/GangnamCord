<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GangnamCord</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-color-primary: #1e1f22;
            --bg-color-secondary: #2b2d31;
            --bg-color-tertiary: #313338;
            --text-color-primary: #f2f3f5;
            --text-color-secondary: #949ba4;
            --highlight-color: #5865f2;
            --highlight-hover: #4752c4;
            --border-color: #1a1a1c;
            --error-color: #f23f43;
            --reply-highlight-color: rgba(255, 165, 0, 0.15);
            --my-message-color: #3a3b40;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color-primary);
            color: var(--text-color-primary);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .sidebar, #chat-window, .right-sidebar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        .sidebar::-webkit-scrollbar, #chat-window::-webkit-scrollbar, .right-sidebar::-webkit-scrollbar {
            display: none;
            width: 0;
            background: transparent;
        }

        .sidebar {
            width: 240px;
            background-color: var(--bg-color-secondary);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
        }
        
        .sidebar-search {
            width: 100%;
            padding: 0.5rem;
            background-color: var(--bg-color-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-color-primary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .sidebar-search::placeholder {
            color: var(--text-color-secondary);
        }

        .sidebar h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--text-color-secondary);
        }

        .channel-list, .dm-list {
            list-style: none;
            padding: 0;
            margin: 0;
            margin-bottom: 1rem;
        }
        
        .channel-list li.active, .dm-list li.active {
            background-color: var(--highlight-color);
            color: var(--text-color-primary);
        }

        .channel-list li:hover:not(.active), .dm-list li:hover:not(.active) {
            background-color: var(--bg-color-tertiary);
        }
        
        .dm-list li {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0.5rem 1rem;
            font-weight: 400;
        }
        
        .dm-list .user-pfp {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-color-primary);
            flex-shrink: 0;
        }
        
        .dm-list .username {
            font-weight: 600;
            color: var(--text-color-secondary);
        }

        .main-content {
            flex-grow: 1;
            background-color: var(--bg-color-tertiary);
            display: flex;
            flex-direction: column;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color-tertiary);
            flex-shrink: 0;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
        }
        
        #reset-app-btn-header, #logout-btn {
            background-color: var(--error-color);
            color: var(--text-color-primary);
            font-weight: 700;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            margin-left: 10px;
        }
        
        #logout-btn {
            background-color: var(--bg-color-secondary);
            color: var(--text-color-secondary);
        }
        #logout-btn:hover {
            background-color: var(--bg-color-primary);
        }

        #reset-app-btn-header:hover {
            background-color: #c22b2f;
            transform: translateY(-1px);
        }

        #chat-window {
            flex-grow: 1;
            padding: 1rem 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            position: relative;
        }
        
        #load-more-messages-btn {
            position: sticky;
            top: 10px;
            align-self: center;
            background-color: var(--highlight-color);
            color: var(--text-color-primary);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            z-index: 10;
        }
        
        #load-more-messages-btn:hover {
            background-color: var(--highlight-hover);
            transform: translateY(-1px);
        }

        .message-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
            position: relative;
        }
        
        .profile-picture {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-color-primary);
            flex-shrink: 0;
            text-transform: uppercase;
        }
        
        .message {
            background-color: var(--bg-color-secondary);
            padding: 1rem;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: background-color 0.2s, transform 0.2s;
            position: relative;
            overflow: visible;
        }
        
        .message.my-message {
            background-color: var(--my-message-color);
            margin-left: auto;
            margin-right: 0;
        }
        
        .message-wrapper.my-message-wrapper {
            flex-direction: row-reverse;
        }

        .message.highlight-for-me {
            background-color: var(--reply-highlight-color);
        }

        .reply-btn, .edit-btn {
            position: absolute;
            top: -30px;
            padding: 4px 8px;
            background-color: rgba(43, 45, 49, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            color: var(--text-color-primary);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            z-index: 5;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out, visibility 0s linear 0.5s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .message-wrapper:hover .reply-btn,
        .message-wrapper:hover .edit-btn {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease-in, visibility 0s linear 0s; 
        }

        .message .reply-btn {
            right: 5px;
        }
        .message .edit-btn {
            right: 80px;
        }

        .my-message-wrapper .message .reply-btn {
            left: 5px;
            right: auto;
        }
        .my-message-wrapper .message .edit-btn {
            left: 80px;
            right: auto;
        }


        .reply-reference {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-color-secondary);
            border-left: 2px solid var(--highlight-color);
            padding-left: 0.5rem;
            line-height: 1.2;
            cursor: pointer;
            transition: color 0.2s, background-color 0.2s;
        }
        
        .reply-reference:hover {
            color: var(--text-color-primary);
            background-color: rgba(88, 101, 242, 0.1);
        }
        
        .reply-reference .reply-icon {
            font-size: 0.8em;
            margin-right: 0.5rem;
        }
        
        .reply-reference .reply-to-name {
            font-weight: 700;
        }

        .message .user-info {
            font-weight: 700;
            color: var(--highlight-color);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }
        
        .message .timestamp {
            font-size: 0.75rem;
            color: var(--text-color-secondary);
            opacity: 0.8;
            margin-left: 0.5rem;
            font-weight: 400;
        }
        
        .message .edited-tag {
            font-size: 0.7rem;
            color: var(--text-color-secondary);
            margin-left: 0.5rem;
            font-weight: 400;
            opacity: 0.7;
        }

        .message .content {
            font-size: 1rem;
            line-height: 1.5;
            color: var(--text-color-primary);
        }

        #image-preview-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            position: relative;
            max-width: fit-content;
        }

        #image-preview {
            max-width: 100px;
            max-height: 100px;
            border-radius: 4px;
            object-fit: contain;
        }

        #cancel-image-btn {
            background: none;
            border: none;
            color: var(--text-color-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            transition: color 0.2s;
            position: absolute;
            top: 5px;
            right: 5px;
        }

        #cancel-image-btn:hover {
            color: var(--error-color);
        }

        .message .message-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            margin-top: 0.5rem;
            display: block;
            object-fit: contain;
        }
        
        .message .link-preview-container {
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 0.5rem;
            background-color: var(--bg-color-tertiary);
            max-width: 300px;
            text-decoration: none;
        }
        .message .link-preview-container:hover {
            filter: brightness(1.1);
        }

        .message .link-preview-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            display: block;
        }

        .message .link-preview-info {
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .message .link-preview-title {
            font-weight: 600;
            color: var(--text-color-primary);
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message .link-preview-description {
            font-size: 0.8rem;
            color: var(--text-color-secondary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .message .link-preview-url {
            font-size: 0.75rem;
            color: var(--highlight-color);
            word-break: break-all;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #message-form {
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-color-tertiary);
            flex-shrink: 0;
        }
        
        #typing-indicator {
            font-size: 0.85rem;
            color: var(--text-color-secondary);
            margin-bottom: 0.5rem;
            min-height: 1.2em;
        }
        
        #reply-status {
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--highlight-color);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #reply-status span {
            color: var(--text-color-primary);
            font-size: 0.9rem;
        }
        
        #cancel-reply-btn {
            background: none;
            border: none;
            color: var(--text-color-secondary);
            cursor: pointer;
            transition: color 0.2s;
        }
        
        #cancel-reply-btn:hover {
            color: var(--error-color);
        }
        
        .message-input-container {
            display: flex;
            gap: 0.75rem;
        }
        
        #emoji-picker-btn, #attach-image-btn {
            background-color: #55575c;
            color: var(--text-color-primary);
            border: none;
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #emoji-picker-btn:hover, #attach-image-btn:hover {
            background-color: var(--highlight-color);
            color: var(--text-color-primary);
            transform: translateY(-1px);
        }

        #message-input {
            flex-grow: 1;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-color-primary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        #message-input:focus {
            outline: none;
            border-color: var(--highlight-color);
            box-shadow: 0 0 0 2px rgba(88, 101, 242, 0.5);
        }

        #message-form button[type="submit"] {
            background-color: var(--highlight-color);
            color: var(--text-color-primary);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            transition: background-color 0.2s, transform 0.1s;
        }

        #message-form button[type="submit"]:hover {
            background-color: var(--highlight-hover);
            transform: translateY(-1px);
        }

        #auth-choice-modal, #register-modal, #login-modal, #reset-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #emoji-picker {
            position: absolute;
            bottom: 110px;
            right: 1.5rem;
            width: 350px;
            height: 400px;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            display: none;
            flex-direction: column;
            z-index: 99;
        }
        
        #emoji-search-input {
            width: 100%;
            background-color: var(--bg-color-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-color-primary);
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        #emoji-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            overflow-y: auto;
            flex-grow: 1;
        }

        #emoji-grid button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            transition: transform 0.1s;
            flex: 0 0 16.66%;
            text-align: center;
        }
        
        #emoji-grid button:hover {
            transform: scale(1.2);
        }

        .modal-content {
            background-color: var(--bg-color-tertiary);
            padding: 2.5rem 3rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            width: 300px;
        }
        
        .modal-content h2 {
            margin-top: 0;
            font-size: 2rem;
            font-weight: 700;
        }
        
        .modal-content input {
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-color-primary);
            padding: 1rem;
            border-radius: 8px;
            font-size: 1rem;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            width: 100%;
        }

        .modal-content button {
            width: 100%;
            background-color: var(--highlight-color);
            color: var(--text-color-primary);
            border: none;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 700;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .modal-content button:hover {
            background-color: var(--highlight-hover);
            transform: translateY(-2px);
        }
        
        .modal-content p.error {
            color: var(--error-color);
            margin-bottom: 1rem;
            font-size: 0.9rem;
            height: 1.2em;
        }
        
        #reset-modal .modal-content h2 {
            font-size: 1.5rem;
        }
        
        #reset-modal .modal-buttons,
        #auth-choice-modal .modal-content .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        #reset-modal .modal-buttons button,
        #auth-choice-modal .modal-content .modal-buttons button {
            width: 50%;
        }
        
        #reset-confirm-btn {
            background-color: var(--error-color);
        }
        
        #reset-confirm-btn:hover {
            background-color: #c22b2f;
        }
        
        #reset-cancel-btn, #login-choice-btn, #register-choice-btn, #register-cancel-btn, #login-cancel-btn {
            background-color: var(--bg-color-secondary);
            color: var(--text-color-secondary);
        }

        #reset-cancel-btn:hover, #login-choice-btn:hover, #register-choice-btn:hover, #register-cancel-btn:hover, #login-cancel-btn:hover {
            background-color: var(--bg-color-primary);
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                max-height: 60px;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 0 1rem;
                border-bottom: 1px solid var(--border-color);
            }
            .sidebar h2 {
                display: none;
            }
            .main-content {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="auth-choice-modal" style="display: none;">
        <div class="modal-content">
            <h2>Welcome to GangnamCord!</h2>
            <div class="modal-buttons">
                <button id="register-choice-btn">Register</button>
                <button id="login-choice-btn">Login</button>
            </div>
        </div>
    </div>

    <div id="register-modal" style="display: none;">
        <div class="modal-content">
            <h2>Register</h2>
            <input type="text" id="register-username-input" placeholder="Choose a Display Name" autocomplete="off">
            <input type="email" id="register-email-input" placeholder="Your Email" autocomplete="email">
            <input type="password" id="register-password-input" placeholder="Choose a Password" autocomplete="new-password">
            <input type="password" id="register-confirm-password-input" placeholder="Confirm Password" autocomplete="new-password">
            <p id="register-error" class="error"></p>
            <button id="register-submit">Register</button>
            <button id="register-cancel-btn" style="margin-top: 1rem;">Cancel</button>
        </div>
    </div>

    <div id="login-modal" style="display: none;">
        <div class="modal-content">
            <h2>Login</h2>
            <input type="email" id="login-email-input" placeholder="Your Email" autocomplete="email">
            <input type="password" id="login-password-input" placeholder="Your Password" autocomplete="current-password">
            <p id="login-error" class="error"></p>
            <button id="login-submit">Login</button>
            <button id="login-cancel-btn" style="margin-top: 1rem;">Cancel</button>
        </div>
    </div>
    
    <div id="reset-modal" style="display: none;">
        <div class="modal-content">
            <h2>Warning!</h2>
            <p>This will permanently delete all chat messages and user names. Are you sure you want to proceed?</p>
            <div class="modal-buttons">
                <button id="reset-confirm-btn">Yes, Reset</button>
                <button id="reset-cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <div class="sidebar">
        <input type="text" id="sidebar-search" class="sidebar-search" placeholder="Search...">
        
        <h2>GROUPS:</h2>
        <ul id="group-list" class="channel-list">
            <li id="general-channel" class="active"># general</li>
        </ul>
        
        <h2>DMS:</h2>
        <ul id="dm-list" class="dm-list">
            <!-- Online users for DM will be dynamically added here -->
        </ul>
    </div>

    <div class="main-content">
        <header>
            <h1 id="current-channel-name"># general</h1>
            <div>
                <button id="logout-btn" style="display:none;">Logout</button>
                <button id="reset-app-btn-header" style="display: none;">Reset App</button>
            </div>
        </header>

        <div id="chat-window">
            <!-- New: Load More button -->
            <button id="load-more-messages-btn" style="display:none;">Load More Messages</button>
            <!-- Messages will be displayed here -->
        </div>
        
        <!-- The emoji picker popup -->
        <div id="emoji-picker" style="display: none;">
            <input type="text" id="emoji-search-input" placeholder="Search emojis..." />
            <div id="emoji-grid">
                <!-- Emojis will be dynamically added here -->
            </div>
        </div>

        <form id="message-form">
            <!-- New: Image preview container -->
            <div id="image-preview-container" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview">
                <button type="button" id="cancel-image-btn"><i class="fa-solid fa-xmark"></i></button>
            </div>

            <div id="reply-status" style="display: none;">
                <span>Replying to: <span id="reply-to-name"></span></span>
                <button type="button" id="cancel-reply-btn"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <!-- New: Typing Indicator -->
            <div id="typing-indicator"></div>
            <div class="message-input-container">
                <button type="button" id="attach-image-btn"><i class="fa-solid fa-paperclip"></i></button>
                <input type="file" id="image-input" accept="image/*" style="display:none;">
                <button type="button" id="emoji-picker-btn">😊</button>
                <input type="text" id="message-input" placeholder="Message #general" autocomplete="off">
                <button type="submit">Send</button>
            </div>
        </form>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { 
            getFirestore, 
            collection, 
            query, 
            where, 
            onSnapshot, 
            addDoc, 
            doc, 
            setDoc,
            getDoc,
            updateDoc, 
            serverTimestamp,
            getDocs,
            deleteDoc,
            orderBy, 
            limit,   
            startAfter, 
        } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
        import { 
            getAuth, 
            onAuthStateChanged, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword,   
            signOut as firebaseSignOut,   
            updateProfile                 
        } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
        
        // --- Firebase Configuration and Initialization ---
        // Your web app's Firebase configuration (provided by the user)
        const firebaseConfig = {
          apiKey: "AIzaSyAd2BAf_ArB5f2hsEBpPyVP7xosX5f27Q8",
          authDomain: "discord-school-3f85b.firebaseapp.com",
          projectId: "discord-school-3f85b",
          storageBucket: "discord-school-3f85b.firebasestorage.app",
          messagingSenderId: "769295138188",
          appId: "1:769295138188:web:0297bf01ceeabf76d02aa9",
          measurementId: "G-3877EJTW46" // Not used in this app's logic
        };
        
        // Use the appId directly from the provided firebaseConfig
        const appId = firebaseConfig.appId; 

        // Initialize Firebase services
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- Cloudinary Configuration (REPLACE THESE WITH YOUR OWN) ---
        const CLOUDINARY_CLOUD_NAME = "dvxypcpj0"; 
        const CLOUDINARY_UPLOAD_PRESET = "gangnamcord_unsigned_upload"; 

        // --- DOM Elements ---
        const sidebarSearchInput = document.getElementById('sidebar-search');
        const groupList = document.getElementById('group-list');
        const dmList = document.getElementById('dm-list');
        const chatWindow = document.getElementById('chat-window');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        
        const authChoiceModal = document.getElementById('auth-choice-modal');
        const registerChoiceBtn = document.getElementById('register-choice-btn');
        const loginChoiceBtn = document.getElementById('login-choice-btn');

        const registerModal = document.getElementById('register-modal');
        const registerUsernameInput = document.getElementById('register-username-input');
        const registerEmailInput = document.getElementById('register-email-input'); 
        const registerPasswordInput = document.getElementById('register-password-input');
        const registerConfirmPasswordInput = document.getElementById('register-confirm-password-input');
        const registerError = document.getElementById('register-error');
        const registerSubmitBtn = document.getElementById('register-submit');
        const registerCancelBtn = document.getElementById('register-cancel-btn');

        const loginModal = document.getElementById('login-modal');
        const loginEmailInput = document.getElementById('login-email-input'); 
        const loginPasswordInput = document.getElementById('login-password-input');
        const loginError = document.getElementById('login-error');
        const loginSubmitBtn = document.getElementById('login-submit');
        const loginCancelBtn = document.getElementById('login-cancel-btn');

        const resetModal = document.getElementById('reset-modal');
        const resetConfirmBtn = document.getElementById('reset-confirm-btn');
        const resetCancelBtn = document.getElementById('reset-cancel-btn');

        const generalChannel = document.getElementById('general-channel');
        const currentChannelName = document.getElementById('current-channel-name');
        const resetAppBtnHeader = document.getElementById('reset-app-btn-header');
        const logoutBtn = document.getElementById('logout-btn'); 

        const replyStatus = document.getElementById('reply-status');
        const replyToNameSpan = document.getElementById('reply-to-name');
        const cancelReplyBtn = document.getElementById('cancel-reply-btn');
        const emojiPickerBtn = document.getElementById('emoji-picker-btn');
        const emojiPicker = document.getElementById('emoji-picker');
        const emojiSearchInput = document.getElementById('emoji-search-input');
        const emojiGrid = document.getElementById('emoji-grid');
        const loadMoreMessagesBtn = document.getElementById('load-more-messages-btn'); 
        const typingIndicator = document.getElementById('typing-indicator');
        
        const attachImageBtn = document.getElementById('attach-image-btn');
        const imageInput = document.getElementById('image-input');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const cancelImageBtn = document.getElementById('cancel-image-btn');

        // --- Global State Variables ---
        const ADMIN_USERNAME = "Admin"; 
        const MIN_PASSWORD_LENGTH = 6; 

        let currentUserId = null;
        let currentUserName = null;
        let currentChannel = 'general';
        let onlineUsersListener = null;
        let messagesListener = null;
        let typingListener = null; 
        let pingInterval = null;
        let replyingTo = { messageId: null, senderName: null, replyToSenderId: null };
        let editingMessageId = null; 
        let attachedImageFile = null; 

        const MESSAGE_COOLDOWN_MS = 2000; 
        let lastSentMessageTime = 0; 

        const initialLoadTimestamp = Date.now();
        
        const MESSAGE_LOAD_LIMIT = 20; 
        let lastVisibleMessage = null; 
        let hasMoreMessages = true; 

        let allOnlineUsers = [];
        let typingUsers = []; 

        const emojis = [
            { emoji: '😀', keywords: ['grinning', 'face', 'smile'] }, { emoji: '😁', keywords: ['grinning', 'eyes', 'face', 'smile'] }, { emoji: '😂', keywords: ['face', 'tears', 'joy', 'laughing'] }, { emoji: '🤣', keywords: ['rolling', 'laughing', 'floor'] }, { emoji: '😃', keywords: ['grinning', 'big', 'smile', 'eyes'] }, { emoji: '😅', keywords: ['grinning', 'face', 'smile', 'sweat'] }, { emoji: '😆', keywords: ['laughing', 'grin', 'face'] }, { emoji: '😉', keywords: ['winking', 'face', 'wink'] }, { emoji: '😊', keywords: ['blushing', 'smiling', 'face', 'happy'] }, { emoji: '😋', keywords: ['savoring', 'food', 'yummy', 'tongue'] }, { emoji: '😎', keywords: ['sunglasses', 'cool', 'face'] }, { emoji: '😍', keywords: ['heart', 'eyes', 'love', 'in love'] }, { emoji: '😘', keywords: ['kissing', 'face', 'kiss'] }, { emoji: '🥰', keywords: ['hearts', 'face', 'love', 'smiling'] }, { emoji: '🤔', keywords: ['thinking', 'face', 'ponder'] }, { emoji: '🤢', keywords: ['nauseated', 'face', 'sick'] }, { emoji: '🤮', keywords: ['vomiting', 'face', 'puke'] }, { emoji: '🤧', keywords: ['sneezing', 'face', 'sneeze'] }, { emoji: '🥵', keywords: ['hot', 'face', 'sweating'] }, { emoji: '🥶', keywords: ['cold', 'face', 'frozen'] }, { emoji: '😵', keywords: ['dizzy', 'face', 'dizzy'] }, { emoji: '🤯', keywords: ['exploding', 'head', 'mindblown'] }, { emoji: '🤠', keywords: ['cowboy', 'hat', 'face'] }, { emoji: '🥳', keywords: ['partying', 'face', 'celebration'] }, { emoji: '🥺', keywords: ['pleading', 'face', 'puppy', 'eyes'] }, { emoji: '😤', keywords: ['steam', 'from', 'nose', 'face', 'triumph'] }, { emoji: '😢', keywords: ['crying', 'face', 'sad'] }, { emoji: '😭', keywords: ['loudly', 'crying', 'face', 'sobbing'] }, { emoji: '💀', keywords: ['skull', 'death', 'dead'] }, { emoji: '👻', keywords: ['ghost', 'halloween'] }, { emoji: '🤖', keywords: ['robot', 'face'] }, { emoji: '💩', keywords: ['poop', 'pile', 'crap'] }, { emoji: '❤️', keywords: ['heart', 'love', 'red'] }, { emoji: '🧡', keywords: ['heart', 'orange'] }, { emoji: '💛', keywords: ['heart', 'yellow'] }, { emoji: '💚', keywords: ['heart', 'green'] }, { emoji: '💙', keywords: ['heart', 'blue'] }, { emoji: '💜', keywords: ['heart', 'purple'] }, { emoji: '🤎', keywords: ['heart', 'brown'] }, { emoji: '🖤', keywords: ['heart', 'black'] }, { emoji: '🤍', keywords: ['heart', 'white'] }, { emoji: '💯', keywords: ['hundred', 'score', 'perfect'] }, { emoji: '👍', keywords: ['thumbs', 'up', 'like', 'good'] }, { emoji: '👎', keywords: ['thumbs', 'down', 'dislike', 'bad'] }, { emoji: '🎉', keywords: ['party', 'popper', 'celebration'] }, { emoji: '🎊', keywords: ['confetti', 'ball', 'celebration'] }, { emoji: '🎈', keywords: ['balloon', 'party'] }, { emoji: '🎁', keywords: ['gift', 'present', 'box'] }, { emoji: '🎂', keywords: ['cake', 'birthday'] }, { emoji: '🍕', keywords: ['pizza', 'slice', 'food'] }, { emoji: '🍔', keywords: ['hamburger', 'burger', 'food'] }, { emoji: '🍟', keywords: ['french', 'fries', 'food'] }, { emoji: '🌮', keywords: ['taco', 'food', 'mexican'] }, { emoji: '🍣', keywords: ['sushi', 'food', 'japanese'] }, { emoji: '☕', keywords: ['coffee', 'tea', 'drink'] }, { emoji: '🍺', keywords: ['beer', 'mug', 'drink'] }, { emoji: '😂', keywords: ['face', 'tears', 'joy', 'laughing'] }, { emoji: '🔥', keywords: ['fire', 'flame', 'hot'] }, { emoji: '🚀', keywords: ['rocket', 'ship', 'launch'] }, { emoji: '💡', keywords: ['light', 'bulb', 'idea'] }, { emoji: '💰', keywords: ['money', 'bag', 'cash'] }, { emoji: '💻', keywords: ['laptop', 'computer', 'tech'] }, { emoji: '📱', keywords: ['mobile', 'phone', 'smartphone'] }, { emoji: '✅', keywords: ['check', 'mark', 'yes', 'correct'] }, { emoji: '❌', keywords: ['cross', 'mark', 'no', 'incorrect'] }, { emoji: '❓', keywords: ['question', 'mark'] }, { emoji: '❗', keywords: ['exclamation', 'mark'] }
        ];

        const USERS_COLLECTION = `artifacts/${appId}/public/data/users`;
        const MESSAGES_COLLECTION = `artifacts/${appId}/public/data/messages`;
        const CONTROL_COLLECTION = `artifacts/${appId}/public/data/control`;

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            let color = '#';
            for (let i = 0; i < 3; i++) {
                let value = (hash >> (i * 8)) & 0xFF;
                color += ('00' + value.toString(16)).padStart(2, '0');
            }
            return color;
        }
        
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        function getYouTubeVideoId(url) {
            const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|\/channel\/[^/]+\/|\/user\/[^/]+\/|youtu\.be\/|\/v\/|\/e\/|\/embed\/|watch\?.*v=|\?.*v=|\&.*v=))([^"&?\/\s]{11})/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }

        async function ping() {
            if (currentUserId) {
                try {
                    const userDocRef = doc(db, USERS_COLLECTION, currentUserId);
                    await updateDoc(userDocRef, { 
                        lastSeen: serverTimestamp(),
                        isTyping: messageInput.value.trim().length > 0 && document.activeElement === messageInput
                    });
                } catch (error) {
                    console.error("Error updating user timestamp:", error);
                }
            }
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                console.log("Firebase user state changed. UID:", user.uid);
                currentUserId = user.uid;

                if (user.isAnonymous) {
                    console.log("Anonymous user detected. Prompting for authentication.");
                    authChoiceModal.style.display = 'flex';
                    logoutBtn.style.display = 'none'; 
                } else {
                    currentUserName = user.displayName;
                    console.log(`User logged in: ${currentUserName} (UID: ${currentUserId})`);
                    
                    authChoiceModal.style.display = 'none';
                    registerModal.style.display = 'none';
                    loginModal.style.display = 'none';

                    const userDocRef = doc(db, USERS_COLLECTION, currentUserId);
                    const userDocSnap = await getDoc(userDocRef);
                    if (!userDocSnap.exists()) {
                        await setDoc(userDocRef, {
                            username: currentUserName, 
                            email: user.email, 
                            lastSeen: serverTimestamp(),
                            isTyping: false
                        });
                    } else {
                        await updateDoc(userDocRef, {
                            username: currentUserName,
                            lastSeen: serverTimestamp(),
                            isTyping: false
                        });
                    }

                    startListening();
                    if (currentUserName === ADMIN_USERNAME) {
                        resetAppBtnHeader.style.display = 'block';
                    } else {
                        resetAppBtnHeader.style.display = 'none';
                    }
                    logoutBtn.style.display = 'inline-block';
                }
            } else {
                console.log("Firebase user is signed out.");
                currentUserId = null;
                currentUserName = null;

                if (onlineUsersListener) onlineUsersListener();
                if (messagesListener) messagesListener();
                if (typingListener) typingListener();
                if (pingInterval) clearInterval(pingInterval);

                resetAppBtnHeader.style.display = 'none';
                logoutBtn.style.display = 'none';
                chatWindow.innerHTML = '';
                dmList.innerHTML = '';
                sidebarSearchInput.value = '';
                currentChannelName.textContent = '# general';
                authChoiceModal.style.display = 'flex'; 

                try {
                    // Attempt to sign in anonymously if no user is present
                    // This ensures there's always a Firebase UID for Firestore interactions even before custom login
                    // and allows the onAuthStateChanged to re-trigger for handling authChoiceModal logic.
                    // This anonymous sign-in is managed by Firebase and is distinct from your custom Email/Password auth.
                    await auth.signInAnonymously();
                    console.log("Signed in anonymously to get a UID.");
                } catch (anonError) {
                    console.error("Error signing in anonymously:", anonError);
                }
            }
        });
        
        registerChoiceBtn.addEventListener('click', () => {
            authChoiceModal.style.display = 'none';
            registerModal.style.display = 'flex';
            registerError.textContent = '';
            registerUsernameInput.value = '';
            registerEmailInput.value = '';
            registerPasswordInput.value = '';
            registerConfirmPasswordInput.value = '';
        });

        loginChoiceBtn.addEventListener('click', () => {
            authChoiceModal.style.display = 'none';
            loginModal.style.display = 'flex';
            loginError.textContent = '';
            loginEmailInput.value = '';
            loginPasswordInput.value = '';
        });

        registerCancelBtn.addEventListener('click', () => {
            registerModal.style.display = 'none';
            authChoiceModal.style.display = 'flex';
        });

        loginCancelBtn.addEventListener('click', () => {
            loginModal.style.display = 'none';
            authChoiceModal.style.display = 'flex';
        });

        registerSubmitBtn.addEventListener('click', async () => {
            const username = registerUsernameInput.value.trim();
            const email = registerEmailInput.value.trim();
            const password = registerPasswordInput.value;
            const confirmPassword = registerConfirmPasswordInput.value;
            registerError.textContent = '';

            if (username.length < 4 || username.length > 15) {
                registerError.textContent = 'Display name must be 4-15 characters.';
                return;
            }
            const profanityList = ['badword', 'swear', 'fuck', 'shit']; 
            if (profanityList.some(word => username.toLowerCase().includes(word))) {
                 registerError.textContent = 'Display name contains inappropriate words.';
                 return;
            }
            if (!email) {
                registerError.textContent = 'Email is required.';
                return;
            }
            if (password.length < MIN_PASSWORD_LENGTH) {
                registerError.textContent = `Password must be at least ${MIN_PASSWORD_LENGTH} characters.`;
                return;
            }
            if (password !== confirmPassword) {
                registerError.textContent = 'Passwords do not match.';
                return;
            }

            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const user = userCredential.user;

                await updateProfile(user, { displayName: username });

                const userDocRef = doc(db, USERS_COLLECTION, user.uid);
                await setDoc(userDocRef, {
                    username: username, 
                    email: email, 
                    lastSeen: serverTimestamp(), 
                    isTyping: false 
                });

                registerModal.style.display = 'none';

            } catch (error) {
                console.error("Error during registration:", error.code, error.message);
                if (error.code === 'auth/email-already-in-use') {
                    registerError.textContent = 'That email address is already in use.';
                } else if (error.code === 'auth/invalid-email') {
                    registerError.textContent = 'Invalid email address format.';
                } else if (error.code === 'auth/weak-password') {
                    registerError.textContent = 'Password is too weak.';
                }
                else {
                    registerError.textContent = 'Registration failed: ' + error.message;
                }
            }
        });

        loginSubmitBtn.addEventListener('click', async () => {
            const email = loginEmailInput.value.trim();
            const password = loginPasswordInput.value;
            loginError.textContent = '';

            if (!email || !password) {
                loginError.textContent = 'Please enter email and password.';
                return;
            }

            try {
                await signInWithEmailAndPassword(auth, email, password);
                loginModal.style.display = 'none';

            } catch (error) {
                console.error("Error during login:", error.code, error.message);
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential' || error.code === 'auth/invalid-email' || error.code === 'auth/user-disabled') {
                    loginError.textContent = 'Invalid email or password.';
                }
                else {
                    loginError.textContent = 'Login failed: ' + error.message;
                }
            }
        });
        
        logoutBtn.addEventListener('click', async () => {
            if (currentUserId) {
                try {
                    await updateDoc(doc(db, USERS_COLLECTION, currentUserId), { 
                        lastSeen: new Date(0), 
                        isTyping: false 
                    });
                    console.log("User status updated to offline.");
                } catch (error) {
                    console.error("Error updating user status on logout:", error);
                }
            }
            firebaseSignOut(auth); 
            console.log("Logged out.");
        });

        window.addEventListener('beforeunload', async () => {
            if (currentUserId) {
                try {
                    await updateDoc(doc(db, USERS_COLLECTION, currentUserId), { 
                        lastSeen: new Date(0),
                        isTyping: false 
                    });
                } catch (error) {
                    console.error("Error updating user status on unload:", error);
                }
            }
        });
        
        resetAppBtnHeader.addEventListener('click', () => {
            if (currentUserName === ADMIN_USERNAME) {
                resetModal.style.display = 'flex';
            } else {
                alert("You do not have permission to reset the application.");
            }
        });

        resetCancelBtn.addEventListener('click', () => {
            resetModal.style.display = 'none';
        });

        resetConfirmBtn.addEventListener('click', async () => {
            resetModal.style.display = 'none';
            if (currentUserName !== ADMIN_USERNAME) {
                console.error("Attempted reset by non-admin user.");
                alert("Permission denied.");
                return;
            }
            try {
                if (onlineUsersListener) onlineUsersListener();
                if (messagesListener) messagesListener();
                if (typingListener) typingListener(); 
                if (pingInterval) clearInterval(pingInterval);

                const usersQuery = query(collection(db, USERS_COLLECTION));
                const usersSnapshot = await getDocs(usersQuery);
                const userDeletions = usersSnapshot.docs.map(d => deleteDoc(d.ref));
                await Promise.all(userDeletions);
                console.log("All users deleted.");

                const messagesQuery = query(collection(db, MESSAGES_COLLECTION));
                const messagesSnapshot = await getDocs(messagesQuery);
                const messageDeletions = messagesSnapshot.docs.map(d => deleteDoc(d.ref));
                await Promise.all(messageDeletions);
                console.log("All messages deleted.");

                const controlDocRef = doc(db, CONTROL_COLLECTION, 'app_state');
                await setDoc(controlDocRef, {
                    lastResetTimestamp: serverTimestamp()
                });

                window.location.reload(); 
            } catch (error) {
                console.error("Error resetting app:", error);
                alert("Failed to reset application. Check console for details.");
            }
        });


        function startListening() {
            if (pingInterval) clearInterval(pingInterval);
            pingInterval = setInterval(ping, 5000); 

            generalChannel.addEventListener('click', () => switchChannel('general', '# general'));
            
            if (onlineUsersListener) onlineUsersListener(); 
            
            const qOnlineUsers = query(collection(db, USERS_COLLECTION));
            
            onlineUsersListener = onSnapshot(qOnlineUsers, snapshot => {
                allOnlineUsers = []; 
                typingUsers = []; 
                const fiveSecondsAgo = new Date(Date.now() - 5000); 
                snapshot.forEach(doc => {
                    const user = doc.data();
                    if (user.lastSeen && user.lastSeen.toDate() > fiveSecondsAgo && doc.id !== currentUserId) {
                        allOnlineUsers.push({ id: doc.id, username: user.username });
                        if (user.isTyping) { 
                            typingUsers.push(user.username);
                        }
                    }
                });
                updateSidebarLists();
                updateTypingIndicator(); 
            });
            
            const controlDocRef = doc(db, CONTROL_COLLECTION, 'app_state');
            onSnapshot(controlDocRef, (doc) => {
                if (doc.exists() && doc.data().lastResetTimestamp) {
                    const resetTimestamp = doc.data().lastResetTimestamp.toDate().getTime();
                    if (resetTimestamp > initialLoadTimestamp) {
                        console.log("Global reset detected, reloading app...");
                        window.location.reload();
                    }
                }
            });
            
            switchChannel('general'); 
        }
        
        function updateSidebarLists(searchTerm = '') {
            const lowerCaseSearch = searchTerm.toLowerCase();

            const groups = [{ id: 'general', name: 'general' }];
            groupList.innerHTML = '';
            groups.forEach(group => {
                if (group.name.toLowerCase().includes(lowerCaseSearch)) {
                    const groupListItem = document.createElement('li');
                    groupListItem.id = `${group.id}-channel`;
                    groupListItem.textContent = `# ${group.name}`;
                    groupListItem.addEventListener('click', () => switchChannel(group.id, `# ${group.name}`));
                    groupList.appendChild(groupListItem);

                    if (currentChannel === group.id) {
                         groupListItem.classList.add('active');
                    }
                }
            });

            dmList.innerHTML = '';
            allOnlineUsers.filter(user => user.id !== currentUserId && user.username.toLowerCase().includes(lowerCaseSearch)).forEach(user => {
                const dmListItem = document.createElement('li');
                dmListItem.dataset.userId = user.id;
                dmListItem.addEventListener('click', () => startDM(user.id, user.username));
                
                const userPfp = document.createElement('div');
                userPfp.classList.add('user-pfp');
                userPfp.style.backgroundColor = stringToColor(user.username);
                userPfp.textContent = user.username.charAt(0).toUpperCase();

                const usernameSpan = document.createElement('span');
                usernameSpan.classList.add('username');
                usernameSpan.textContent = user.username;
                
                dmListItem.appendChild(userPfp);
                dmListItem.appendChild(usernameSpan);
                dmList.appendChild(dmListItem);

                if (currentChannel === [currentUserId, user.id].sort().join('_')) {
                    dmListItem.classList.add('active');
                }
            });
        }
        
        sidebarSearchInput.addEventListener('input', (e) => {
            updateSidebarLists(e.target.value);
        });

        function switchChannel(channelId, channelName = '# general', dmRecipientName = null) {
            if (messagesListener) messagesListener();
            if (typingListener) typingListener(); 

            currentChannel = channelId;
            chatWindow.innerHTML = ''; 
            lastVisibleMessage = null; 
            hasMoreMessages = true; 
            loadMoreMessagesBtn.style.display = 'none'; 
            
            chatWindow.appendChild(loadMoreMessagesBtn);

            document.querySelectorAll('.channel-list li, .dm-list li').forEach(li => li.classList.remove('active'));

            if (channelId === 'general') {
                generalChannel.classList.add('active');
                currentChannelName.textContent = '# general';
                messageInput.placeholder = 'Message #general';
            } else {
                const dmRecipientId = channelId.split('_').filter(id => id !== currentUserId)[0];
                const userListItem = dmList.querySelector(`[data-user-id="${dmRecipientId}"]`);
                if (userListItem) userListItem.classList.add('active');
                currentChannelName.textContent = `@ ${dmRecipientName || allOnlineUsers.find(u => u.id === dmRecipientId)?.username || 'Unknown'}`;
                messageInput.placeholder = `Message @${dmRecipientName || allOnlineUsers.find(u => u.id === dmRecipientId)?.username || 'Unknown'}`;
            }
            
            listenForMessages(channelId, true); 
            listenForTypingStatus(channelId); 
            resetFormState(); 
        }
        
        function startDM(userId, username) {
            const dmId = [currentUserId, userId].sort().join('_');
            switchChannel(dmId, null, username);
        }

        async function listenForMessages(channelId, isInitialLoad = false) {
            const messagesRef = collection(db, MESSAGES_COLLECTION);
            let qMessages;

            if (isInitialLoad) {
                qMessages = query(
                    messagesRef,
                    where('channelId', '==', channelId),
                    orderBy('createdAt', 'desc'), 
                    limit(MESSAGE_LOAD_LIMIT)
                );
            } else {
                qMessages = query(
                    messagesRef,
                    where('channelId', '==', channelId),
                    orderBy('createdAt', 'desc'),
                    startAfter(lastVisibleMessage), 
                    limit(MESSAGE_LOAD_LIMIT)
                );
            }

            messagesListener = onSnapshot(qMessages, async snapshot => {
                const newMessages = [];
                const currentScrollHeight = chatWindow.scrollHeight;
                const currentScrollTop = chatWindow.scrollTop;
                const isAtBottom = chatWindow.scrollHeight - chatWindow.scrollTop <= chatWindow.clientHeight + 1; 

                if (!snapshot.empty) {
                    lastVisibleMessage = snapshot.docs[snapshot.docs.length - 1]; 
                } else {
                    hasMoreMessages = false;
                    loadMoreMessagesBtn.style.display = 'none';
                    return;
                }

                snapshot.forEach(doc => {
                    newMessages.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                newMessages.sort((a, b) => a.createdAt - b.createdAt); 

                if (isInitialLoad) {
                    Array.from(chatWindow.children).forEach(child => {
                        if (child !== loadMoreMessagesBtn) {
                            chatWindow.removeChild(child);
                        }
                    });
                    newMessages.forEach(msg => displayMessage(msg));
                    chatWindow.scrollTop = chatWindow.scrollHeight; 
                    
                    if (snapshot.size === MESSAGE_LOAD_LIMIT) {
                        loadMoreMessagesBtn.style.display = 'block';
                    } else {
                        loadMoreMessagesBtn.style.display = 'none';
                        hasMoreMessages = false;
                    }
                } else {
                    newMessages.forEach(msg => {
                        const existingMsg = document.getElementById(`message-${msg.id}`);
                        if (!existingMsg) { 
                            const messageElement = createMessageElement(msg); 
                            chatWindow.insertBefore(messageElement, loadMoreMessagesBtn.nextSibling);
                        }
                    });

                    chatWindow.scrollTop = currentScrollTop + (chatWindow.scrollHeight - currentScrollHeight);
                    if (snapshot.size < MESSAGE_LOAD_LIMIT) {
                         hasMoreMessages = false;
                         loadMoreMessagesBtn.style.display = 'none';
                    } else {
                        hasMoreMessages = true; 
                        loadMoreMessagesBtn.style.display = 'block';
                    }
                }
                
                if (!isInitialLoad && isAtBottom && snapshot.docChanges().some(change => change.type === 'added')) {
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }

            }, (error) => {
                console.error("Error in snapshot listener:", error);
                console.error("A Firestore security rule or index may be missing. Please check your Firebase console for the required settings.");
                console.error("The full error is:", error.message);
                alert("Failed to load messages. Check console for details.");
            });
        }
        
        function listenForTypingStatus(channelId) {
            if (typingListener) typingListener(); 

            const qTypingUsers = query(collection(db, USERS_COLLECTION));

            typingListener = onSnapshot(qTypingUsers, (snapshot) => {
                typingUsers = [];
                const fiveSecondsAgo = new Date(Date.now() - 5000); 

                snapshot.forEach(doc => {
                    const user = doc.data();
                    if (user.lastSeen && user.lastSeen.toDate() > fiveSecondsAgo && doc.id !== currentUserId) {
                        if (channelId === 'general') {
                             typingUsers.push(user.username);
                        } else {
                            const dmRecipientId = channelId.split('_').filter(id => id !== currentUserId)[0];
                            if (doc.id === dmRecipientId) {
                                typingUsers.push(user.username);
                            }
                        }
                    }
                });
                updateTypingIndicator();
            });
        }

        function updateTypingIndicator() {
            if (typingUsers.length === 0) {
                typingIndicator.textContent = '';
            } else if (typingUsers.length === 1) {
                typingIndicator.textContent = `${typingUsers[0]} is typing...`;
            } else if (typingUsers.length === 2) {
                typingIndicator.textContent = `${typingUsers[0]} and ${typingUsers[1]} are typing...`;
            } else {
                typingIndicator.textContent = `${typingUsers.slice(0, 2).join(', ')} and ${typingUsers.length - 2} more are typing...`;
            }
        }

        const setTypingStatus = debounce(async (isTyping) => {
            if (currentUserId) {
                const userDocRef = doc(db, USERS_COLLECTION, currentUserId);
                await updateDoc(userDocRef, { isTyping: isTyping });
            }
        }, 500); 

        messageInput.addEventListener('input', () => {
            setTypingStatus(messageInput.value.trim().length > 0);
        });

        messageInput.addEventListener('focus', () => {
            setTypingStatus(messageInput.value.trim().length > 0);
        });

        messageInput.addEventListener('blur', () => {
            setTypingStatus(false); 
        });


        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const text = messageInput.value.trim();
            const currentTime = Date.now();
            
            if (currentTime - lastSentMessageTime < MESSAGE_COOLDOWN_MS) {
                alert(`Please wait ${((MESSAGE_COOLDOWN_MS - (currentTime - lastSentMessageTime)) / 1000).toFixed(1)} seconds before sending another message.`);
                return;
            }

            if (text === '' && !attachedImageFile) {
                return;
            }
            if (!currentUserId || !currentUserName) { 
                alert("You must be logged in to send messages.");
                return;
            }
            
            try {
                let imageUrl = null;
                let detectedLink = null;
                let linkThumbnail = null;
                let linkTitle = null;
                let linkDescription = null;

                if (attachedImageFile) {
                    imageUrl = await uploadImageToCloudinary(attachedImageFile);
                    if (!imageUrl) {
                        alert("Failed to upload image. Please try again.");
                        return;
                    }
                }

                const urlRegex = /(https?:\/\/[^\s]+)/g;
                const matches = text.match(urlRegex);
                if (matches && matches.length > 0) {
                    detectedLink = matches[0];
                    
                    const youtubeVideoId = getYouTubeVideoId(detectedLink);
                    if (youtubeVideoId) {
                        linkThumbnail = `https://img.youtube.com/vi/${youtubeVideoId}/hqdefault.jpg`;
                        linkTitle = "YouTube Video"; 
                        linkDescription = "Click to watch on YouTube";
                    } else {
                        linkTitle = "External Link";
                        linkDescription = "Click to visit website";
                    }
                }

                if (editingMessageId) {
                    const messageDocRef = doc(db, MESSAGES_COLLECTION, editingMessageId);
                    await updateDoc(messageDocRef, {
                        text: text,
                        editedAt: serverTimestamp(),
                    });
                    console.log("Message updated:", editingMessageId);
                } else {
                    const messageData = {
                        text: text,
                        createdAt: serverTimestamp(),
                        senderId: currentUserId,
                        senderName: currentUserName,
                        channelId: currentChannel
                    };
                    if (replyingTo.messageId) {
                        messageData.replyToMessageId = replyingTo.messageId;
                        messageData.replyToSenderName = replyingTo.senderName;
                        messageData.replyToSenderId = replyingTo.replyToSenderId;
                    }
                    if (imageUrl) { 
                        messageData.imageUrl = imageUrl;
                    }
                    if (detectedLink) {
                        messageData.detectedLink = detectedLink;
                        if (linkThumbnail) messageData.linkThumbnail = linkThumbnail;
                        if (linkTitle) messageData.linkTitle = linkTitle;
                        if (linkDescription) messageData.linkDescription = linkDescription;
                    }

                    await addDoc(collection(db, MESSAGES_COLLECTION), messageData);
                    console.log("Message sent.");
                    lastSentMessageTime = currentTime;
                }
                
                resetFormState(); 
            } catch (error) {
                console.error("Error sending/editing message or uploading media:", error);
                alert("Failed to send/edit message or upload media. Please try again.");
            }
        });

        function resetFormState() {
            replyingTo = { messageId: null, senderName: null, replyToSenderId: null };
            editingMessageId = null;
            attachedImageFile = null; 
            imageInput.value = '';
            imagePreviewContainer.style.display = 'none'; 
            imagePreview.src = '#'; 
            replyStatus.style.display = 'none';
            messageInput.value = ''; 
            if (currentChannel === 'general') {
                messageInput.placeholder = `Message #general`;
            } else {
                const dmRecipientId = currentChannel.split('_').filter(id => id !== currentUserId)[0];
                const dmRecipientName = allOnlineUsers.find(u => u.id === dmRecipientId)?.username;
                if (dmRecipientName) {
                    messageInput.placeholder = `Message @${dmRecipientName}`;
                } else {
                    messageInput.placeholder = `Message in DM`;
                }
            }
            setTypingStatus(false); 
        }
        cancelReplyBtn.addEventListener('click', resetFormState); 
        cancelImageBtn.addEventListener('click', resetFormState); 

        function setReplyState(messageId, senderName, replyToSenderId) {
            resetFormState(); 
            replyingTo.messageId = messageId;
            replyingTo.senderName = senderName;
            replyingTo.replyToSenderId = replyToSenderId;
            replyStatus.style.display = 'flex';
            replyToNameSpan.textContent = senderName;
            messageInput.placeholder = `Replying to @${senderName}...`;
            messageInput.focus();
        }

        function setEditState(messageId, messageText) {
            resetFormState(); 
            editingMessageId = messageId;
            messageInput.value = messageText;
            replyStatus.style.display = 'flex'; 
            replyToNameSpan.textContent = `Editing message`; 
            messageInput.placeholder = `Editing your message...`;
            messageInput.focus();
        }

        function createProfilePicture(username, size = 'large') {
            const initial = username.charAt(0).toUpperCase();
            const color = stringToColor(username);
            const profilePicElement = document.createElement('div');
            profilePicElement.classList.add('profile-picture');
            if (size === 'small') {
                profilePicElement.classList.remove('profile-picture');
                profilePicElement.classList.add('user-pfp');
            }
            profilePicElement.style.backgroundColor = color;
            profilePicElement.textContent = initial;
            return profilePicElement;
        }

        function createMessageElement(message) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('message-wrapper');
            messageWrapper.id = `message-${message.id}`; 

            const isMyMessage = message.senderId === currentUserId;
            if (isMyMessage) {
                messageWrapper.classList.add('my-message-wrapper');
            }

            const profilePicElement = createProfilePicture(message.senderName);
            messageWrapper.appendChild(profilePicElement);

            const messageContentContainer = document.createElement('div');
            messageContentContainer.classList.add('message');
            if (isMyMessage) {
                messageContentContainer.classList.add('my-message');
            }

            if (message.replyToMessageId && message.replyToSenderId === currentUserId) {
                messageContentContainer.classList.add('highlight-for-me');
            }

            if (message.replyToMessageId) {
                const replyReference = document.createElement('div');
                replyReference.classList.add('reply-reference');
                replyReference.innerHTML = `
                    <i class="fa-solid fa-reply-icon"></i>
                    Replying to <span class="reply-to-name">@${message.replyToSenderName}</span>
                `;
                replyReference.addEventListener('click', () => {
                    const originalMessage = document.getElementById(`message-${message.replyToMessageId}`);
                    if (originalMessage) {
                        originalMessage.scrollIntoView({ behavior: 'smooth', block: 'center' }); 
                        originalMessage.style.transition = 'background-color 0.5s';
                        originalMessage.style.backgroundColor = 'rgba(88, 101, 242, 0.2)';
                        setTimeout(() => {
                            originalMessage.style.backgroundColor = '';
                        }, 1000);
                    }
                });
                messageContentContainer.appendChild(replyReference);
            }

            const color = stringToColor(message.senderName);
            const formattedTime = message.createdAt ? new Date(message.createdAt.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Sending...';

            let userInfoHTML = `
                <div class="user-info" style="color: ${color};">
                    ${message.senderName} ${isMyMessage ? '<span style="color: var(--text-color-secondary); font-weight: 400;">(You)</span>' : ''}
                    <span class="timestamp">${formattedTime}</span>
            `;
            if (message.editedAt) {
                userInfoHTML += `<span class="edited-tag">(edited)</span>`;
            }
            userInfoHTML += `</div>`;


            messageContentContainer.innerHTML += `
                ${userInfoHTML}
                <div class="content">${message.text || ''}</div>
            `;

            if (message.imageUrl) { 
                const imgElement = document.createElement('img');
                imgElement.src = message.imageUrl;
                imgElement.classList.add('message-image');
                imgElement.alt = "Attached image";
                messageContentContainer.appendChild(imgElement);
            }

            if (message.detectedLink) {
                const linkPreviewAnchor = document.createElement('a');
                linkPreviewAnchor.href = message.detectedLink;
                linkPreviewAnchor.target = "_blank";
                linkPreviewAnchor.rel = "noopener noreferrer";
                linkPreviewAnchor.classList.add('link-preview-container');

                if (message.linkThumbnail) {
                    const img = document.createElement('img');
                    img.src = message.linkThumbnail;
                    img.classList.add('link-preview-image');
                    img.alt = "Link preview image";
                    linkPreviewAnchor.appendChild(img);
                }

                const infoDiv = document.createElement('div');
                infoDiv.classList.add('link-preview-info');

                const title = document.createElement('div');
                title.classList.add('link-preview-title');
                title.textContent = message.linkTitle || message.detectedLink;
                infoDiv.appendChild(title);

                if (message.linkDescription) {
                    const description = document.createElement('div');
                    description.classList.add('link-preview-description');
                    description.textContent = message.linkDescription;
                    infoDiv.appendChild(description);
                }
                
                const urlDisplay = document.createElement('div');
                urlDisplay.classList.add('link-preview-url');
                urlDisplay.textContent = new URL(message.detectedLink).hostname;
                infoDiv.appendChild(urlDisplay);

                linkPreviewAnchor.appendChild(infoDiv);
                messageContentContainer.appendChild(linkPreviewAnchor);
            }
            
            const replyButton = document.createElement('button');
            replyButton.classList.add('reply-btn');
            replyButton.innerHTML = `Reply <i class="fa-solid fa-reply"></i>`; 
            replyButton.setAttribute('title', `Reply to ${message.senderName}`);
            replyButton.addEventListener('click', (e) => {
                e.stopPropagation(); 
                setReplyState(message.id, message.senderName, message.senderId);
            });
            messageContentContainer.appendChild(replyButton);

            if (isMyMessage) {
                const editButton = document.createElement('button');
                editButton.classList.add('edit-btn');
                editButton.innerHTML = `Edit <i class="fa-solid fa-pen-to-square"></i>`; 
                editButton.setAttribute('title', `Edit your message`);
                editButton.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    setEditState(message.id, message.text);
                });
                messageContentContainer.appendChild(editButton);
            }

            messageWrapper.appendChild(messageContentContainer);
            
            return messageWrapper;
        }

        function displayMessage(message) {
            const messageElement = createMessageElement(message);
            chatWindow.appendChild(messageElement);
        }
        
        loadMoreMessagesBtn.addEventListener('click', () => {
            if (hasMoreMessages && lastVisibleMessage) {
                listenForMessages(currentChannel, false); 
            } else {
                loadMoreMessagesBtn.style.display = 'none'; 
            }
        });

        emojiPickerBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            emojiPicker.style.display = emojiPicker.style.display === 'flex' ? 'none' : 'flex';
            emojiSearchInput.focus(); 
        });
        
        function createEmojiButtons(filteredEmojis) {
            emojiGrid.innerHTML = '';
            filteredEmojis.forEach(emojiObj => {
                const emojiButton = document.createElement('button');
                emojiButton.textContent = emojiObj.emoji;
                emojiButton.addEventListener('click', () => {
                    messageInput.value += emojiObj.emoji;
                    messageInput.focus();
                    emojiPicker.style.display = 'none'; 
                    setTypingStatus(messageInput.value.trim().length > 0); 
                });
                emojiGrid.appendChild(emojiButton);
            });
        }

        emojiSearchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const filteredEmojis = emojis.filter(emojiObj => {
                return emojiObj.keywords.some(keyword => keyword.includes(searchTerm));
            });
            createEmojiButtons(filteredEmojis);
        });
        
        document.addEventListener('click', (e) => {
            if (!emojiPicker.contains(e.target) && e.target !== emojiPickerBtn) {
                emojiPicker.style.display = 'none';
            }
        });

        createEmojiButtons(emojis);


        attachImageBtn.addEventListener('click', () => {
            imageInput.click(); 
        });

        imageInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                alert("Please select an image file.");
                imageInput.value = ''; 
                return;
            }

            try {
                const optimizedBlob = await resizeAndCompressImage(file, 800, 0.7); 
                attachedImageFile = optimizedBlob;

                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.src = e.target.result;
                    imagePreviewContainer.style.display = 'flex'; 
                };
                reader.readAsDataURL(optimizedBlob);

                messageInput.placeholder = "Add a caption or send image only...";
                messageInput.focus();

            } catch (error) {
                console.error("Error processing image from file input:", error);
                alert("Failed to process image. Please try a different one.");
                resetFormState();
            }
        });

        messageInput.addEventListener('paste', async (event) => {
            event.preventDefault(); 
            const clipboardData = event.clipboardData;

            if (!clipboardData) {
                 const pastedText = event.clipboardData.getData('text/plain');
                 document.execCommand('insertText', false, pastedText);
                 return;
            }

            const items = clipboardData.items;
            if (!items) {
                 const pastedText = event.clipboardData.getData('text/plain');
                 document.execCommand('insertText', false, pastedText);
                 return;
            }

            let imageFound = false;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.startsWith('image/')) {
                    imageFound = true;
                    const file = items[i].getAsFile();
                    if (!file) continue;

                    try {
                        const optimizedBlob = await resizeAndCompressImage(file, 800, 0.7); 
                        attachedImageFile = optimizedBlob;

                        const reader = new FileReader();
                        reader.onload = (e) => {
                            imagePreview.src = e.target.result;
                            imagePreviewContainer.style.display = 'flex'; 
                        };
                        reader.readAsDataURL(optimizedBlob);

                        messageInput.placeholder = "Add a caption or send image only...";
                        messageInput.focus();
                        return; 

                    } catch (error) {
                        console.error("Error processing pasted image:", error);
                        alert("Failed to process pasted image. Please try a different one.");
                        resetFormState();
                        return;
                    }
                }
            }
            
            if (!imageFound) {
                const pastedText = clipboardData.getData('text/plain');
                document.execCommand('insertText', false, pastedText);
            }
        });


        function resizeAndCompressImage(file, maxWidth, quality) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (readerEvent) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height *= maxWidth / width;
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxWidth) {
                                width *= maxWidth / height;
                                height = maxWidth;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas toBlob failed.'));
                            }
                        }, 'image/jpeg', quality); 
                    };
                    img.onerror = (error) => reject(error);
                    img.src = readerEvent.target.result;
                };
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }

        async function uploadImageToCloudinary(imageBlob) {
            if (!CLOUDINARY_CLOUD_NAME || !CLOUDINARY_UPLOAD_PRESET) {
                alert("Cloudinary configuration missing. Please set CLOUDINARY_CLOUD_NAME and CLOUDINARY_UPLOAD_PRESET.");
                console.error("Cloudinary configuration missing.");
                return null;
            }

            const formData = new FormData();
            formData.append('file', imageBlob);
            formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);

            try {
                const response = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`, {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Cloudinary upload failed: ${errorData.error.message}`);
                }

                const data = await response.json();
                console.log("Image uploaded to Cloudinary:", data.secure_url);
                return data.secure_url; 
            } catch (error) {
                console.error("Error uploading to Cloudinary:", error);
                return null;
            }
        }

    </script>
</body>
</html>
